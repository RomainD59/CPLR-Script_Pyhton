commente mon code pr√©cise au d√©but du code que la partie commentaire a √©tait r√©alis√© par copilot par pareil pour ces moments qui est on aussi √©tait g√©n√©rer avec l'IA 

Webhook discord 
Logs
Status.json 

Copilot
Voici une version comment√©e de ton code Python, avec une mention claire que la section de commentaires a √©t√© r√©alis√©e par Copilot. J‚Äôai √©galement ajout√© des titres pour les sections importantes comme Webhook Discord et Logs/Status.json pour plus de clart√©.


# ============================================
# Commentaires g√©n√©r√©s par Copilot
# Script de surveillance de services web
# ============================================

import csv
import requests
import argparse
import os
import json
import ssl
import socket
from datetime import datetime, timedelta

# Fichier de configuration contenant les services √† surveiller
CONFIG_FILE = 'web_services.csv'

# Cr√©e le fichier de configuration s'il n'existe pas
def create_config_file():
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Name', 'URL', 'Webhook', 'SSL_Expiry_Threshold'])

# Lit le fichier de configuration et retourne la liste des services
def read_config_file():
    with open(CONFIG_FILE, 'r') as file:
        reader = csv.DictReader(file)
        return list(reader)

# Ajoute un nouveau site au fichier de configuration
def add_site(name, url, webhook="", ssl_expiry_threshold=30):
    with open(CONFIG_FILE, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([name, url, webhook, ssl_expiry_threshold])
    print(f"Ajout√© : {name} -> {url} (Webhook: {webhook if webhook else 'Aucun'}, SSL Expiry Threshold: {ssl_expiry_threshold} jours)")

# Supprime un site du fichier de configuration
def remove_site(name):
    sites = read_config_file()
    with open(CONFIG_FILE, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(['Name', 'URL', 'Webhook', 'SSL_Expiry_Threshold'])
        for site in sites:
            if site['Name'] != name:
                writer.writerow([site['Name'], site['URL'], site.get('Webhook', ''), site.get('SSL_Expiry_Threshold', 30)])
    print(f"Supprim√© : {name}")

# Affiche la liste des sites configur√©s
def list_sites():
    sites = read_config_file()
    if not sites:
        print("Aucun site configur√©.")
    for site in sites:
        print(f"{site['Name']} -> {site['URL']} (Webhook: {site.get('Webhook', 'Aucun')}, SSL Expiry Threshold: {site.get('SSL_Expiry_Threshold', 30)} jours)")

# ============================================
# Webhook Discord
# ============================================

# Envoie une notification √† un webhook Discord
def send_discord_notification(webhook_url, message):
    try:
        requests.post(webhook_url, json={"content": message})
    except Exception as e:
        print(f"Erreur lors de l'envoi Discord : {e}")

# V√©rifie la date d'expiration du certificat SSL
def check_ssl_expiry(hostname, threshold_days):
    context = ssl.create_default_context()
    with socket.create_connection((hostname, 443)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            days_to_expiry = (expiry_date - datetime.utcnow()).days
            if days_to_expiry < threshold_days:
                return True, expiry_date
            else:
                return False, expiry_date

# ============================================
# Logs et Status.json
# ============================================

# V√©rifie l'√©tat des sites et enregistre les r√©sultats
def check_sites(discord_enabled=False):
    sites = read_config_file()

    log_dir = "log"
    os.makedirs(log_dir, exist_ok=True)

    timestamp = datetime.now().strftime('%Y%m%d_%H_%M_%S')
    log_file = os.path.join(log_dir, f"log_{timestamp}.csv")
    file_exists = os.path.isfile(log_file)

    status_file = "status.json"
    if os.path.exists(status_file):
        with open(status_file, 'r') as f:
            previous_status = json.load(f)
    else:
        previous_status = {}

    current_status = {}

    with open(log_file, 'a', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(["Date/Heure", "Nom", "URL", "Code HTTP", "Erreur", "Statut", "SSL Expiry Date"])

        for site in sites:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            try:
                response = requests.get(site['URL'], timeout=5)
                status_code = response.status_code
                status = "UP" if 200 <= status_code < 300 else "DOWN"
                error = ""
                print(f"[OK] {site['Name']} est en ligne.")
            except Exception as e:
                status_code = "N/A"
                status = "DOWN"
                error = str(e)
                print(f"[HORS LIGNE] {site['Name']} : {e}")

            ssl_warning = False
            ssl_expiry_date = ""
            if status == "UP":
                hostname = site['URL'].split("//")[-1].split("/")[0]
                threshold_days = int(site.get('SSL_Expiry_Threshold', 30))
                ssl_warning, ssl_expiry_date = check_ssl_expiry(hostname, threshold_days)
                if ssl_warning:
                    status = "WARNING_SSL"
                    print(f"[WARNING_SSL] {site['Name']} : Le certificat SSL expire bient√¥t.")

            writer.writerow([now, site['Name'], site['URL'], status_code, error, status, ssl_expiry_date])
            current_status[site['Name']] = status

            if discord_enabled and 'Webhook' in site and site['Webhook']:
                previous = previous_status.get(site['Name'])
                if previous != status:
                    emoji = "üü¢" if status == "UP" else "üî¥" if status == "DOWN" else "‚ö†Ô∏è"
                    message = f"{emoji} **{site['Name']}** est **{status}** (√©tait {previous})\n{site['URL']}"
                    if status == "WARNING_SSL":
                        message += f"\nLe certificat SSL expire le {ssl_expiry_date}."
                    send_discord_notification(site['Webhook'], message)

    with open(status_file, 'w') as f:
        json.dump(current_status, f, indent=2)

    print(f"\n‚úÖ Fichier de log g√©n√©r√© : {log_file}")

# Exporte l'historique des v√©rifications pour un ou plusieurs sites
def export_site_history(site_names):
    log_dir = "log"
    export_dir = "export"
    os.makedirs(export_dir, exist_ok=True)

    timestamp = datetime.now().strftime('%Y%m%d_%H_%M_%S')
    export_file = os.path.join(export_dir, f"export_{timestamp}.csv")

    with open(export_file, 'w', newline='', encoding='utf-8') as export:
        writer = csv.writer(export)
        writer.writerow(["Date/Heure", "Nom", "URL", "Code HTTP", "Erreur", "Statut", "SSL Expiry Date"])

        for log_file in os.listdir(log_dir):
            if log_file.endswith(".csv"):
                with open(os.path.join(log_dir, log_file), 'r', encoding='utf-8') as log:
                    reader = csv.DictReader(log)
                    for row in reader:
                        if row['Nom'] in site_names:
                            writer.writerow([row["Date/Heure"], row["Nom"], row["URL"], row["Code HTTP"], row["Erreur"], row["Statut"], row["SSL Expiry Date"]])

    print(f"\n‚úÖ Rapport export√© : {export_file}")

# Point d'entr√©e principal du script
def main():
    parser = argparse.ArgumentParser(description="Surveillance de services web")
    parser.add_argument('--add', nargs='+', help="Ajouter un site (optionnel : webhook, SSL expiry threshold)")
    parser.add_argument('--remove', metavar='NOM', help="Supprimer un site")
    parser.add_argument('--list', action='store_true', help="Lister les sites")
    parser.add_argument('--check', action='store_true', help="V√©rifier les sites")
    parser.add_argument('--discord', action='store_true', help="Envoyer les changements d'√©tat sur Discord")
    parser.add_argument('--export', nargs='+', metavar='NOM', help="Exporter l'historique des v√©rifications pour un ou plusieurs sites")

    args = parser.parse_args()
    create_config_file()

    if args.add:
        if len(args.add) < 2:
            print("Erreur : vous devez fournir au moins un nom et une URL.")
        else:
            name = args.add[0]
            url = args.add[1]
            webhook = args.add[2] if len(args.add) > 2 else ""
            ssl_expiry_threshold = args.add[3] if len(args.add) > 3 else 30
            add_site(name, url, webhook, ssl_expiry_threshold)
    elif args.remove:
        remove_site(args.remove)
    elif args.list:
        list_sites()
    elif args.check:
        check_sites(discord_enabled=args.discord)
    elif args.export:
        export_site_history(args.export)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()


# Lire le contenu du fichier original
with open('main 1.py', 'r') as file:
    original_code = file.read()

# Ajouter des commentaires d√©taill√©s au code
commented_code = """
### üõ†Ô∏è **Importation des modules**
import csv  # Pour lire et √©crire dans des fichiers CSV
import requests  # Pour effectuer des requ√™tes HTTP
import argparse  # Pour g√©rer les arguments en ligne de commande
import os  # Pour interagir avec le syst√®me de fichiers
import json  # Pour lire et √©crire des fichiers JSON
import ssl  # Pour g√©rer les connexions SSL
import socket  # Pour √©tablir des connexions r√©seau
from datetime import datetime, timedelta  # Pour manipuler les dates et heures

### üìÅ **Fichier de configuration**
CONFIG_FILE = 'web_services.csv'  # Nom du fichier CSV contenant les services √† surveiller

### üìÑ **Cr√©ation du fichier de configuration**
def create_config_file():
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Name', 'URL', 'Webhook', 'SSL_Expiry_Threshold'])  # En-t√™tes du fichier

### üìñ **Lecture du fichier de configuration**
def read_config_file():
    with open(CONFIG_FILE, 'r') as file:
        reader = csv.DictReader(file)
        return list(reader)  # Retourne une liste de dictionnaires repr√©sentant les services

### ‚ûï **Ajout d‚Äôun site**
def add_site(name, url, webhook="", ssl_expiry_threshold=30):
    with open(CONFIG_FILE, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([name, url, webhook, ssl_expiry_threshold])
    print(f"Ajout√© : {name} -> {url} (Webhook: {webhook if webhook else 'Aucun'}, SSL Expiry Threshold: {ssl_expiry_threshold} jours)")

### ‚ûñ **Suppression d‚Äôun site**
def remove_site(name):
    sites = read_config_file()
    with open(CONFIG_FILE, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(['Name', 'URL', 'Webhook', 'SSL_Expiry_Threshold'])  # R√©√©criture de l'en-t√™te
        for site in sites:
            if site['Name'] != name:
                writer.writerow([site['Name'], site['URL'], site.get('Webhook', ''), site.get('SSL_Expiry_Threshold', 30)])
    print(f"Supprim√© : {name}")

### üìã **Liste des sites**
def list_sites():
    sites = read_config_file()
    if not sites:
        print("Aucun site configur√©.")
    for site in sites:
        print(f"{site['Name']} -> {site['URL']} (Webhook: {site.get('Webhook', 'Aucun')}, SSL Expiry Threshold: {site.get('SSL_Expiry_Threshold', 30)} jours)")

### üì¢ **Notification Discord**
def send_discord_notification(webhook_url, message):
    try:
        requests.post(webhook_url, json={"content": message})
    except Exception as e:
        print(f"Erreur lors de l'envoi Discord : {e}")

### üîí **V√©rification du certificat SSL**
def check_ssl_expiry(hostname, threshold_days):
    context = ssl.create_default_context()
    with socket.create_connection((hostname, 443)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            days_to_expiry = (expiry_date - datetime.utcnow()).days
            if days_to_expiry < threshold_days:
                return True, expiry_date
            else:
                return False, expiry_date

### ‚úÖ **V√©rification des sites et g√©n√©ration de logs**
def check_sites(discord_enabled=False):
    sites = read_config_file()
    log_dir = "log"
    os.makedirs(log_dir, exist_ok=True)
    timestamp = datetime.now().strftime('%Y%m%d_%H_%M_%S')
    log_file = os.path.join(log_dir, f"log_{timestamp}.csv")
    file_exists = os.path.isfile(log_file)
    status_file = "status.json"

    # Chargement de l'√©tat pr√©c√©dent
    if os.path.exists(status_file):
        with open(status_file, 'r') as f:
            previous_status = json.load(f)
    else:
        previous_status = {}

    current_status = {}

    with open(log_file, 'a', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(["Date/Heure", "Nom", "URL", "Code HTTP", "Erreur", "Statut", "SSL Expiry Date"])

        for site in sites:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            try:
                response = requests.get(site['URL'], timeout=5)
                status_code = response.status_code
                status = "UP" if 200 <= status_code < 300 else "DOWN"
                error = ""
                print(f"[OK] {site['Name']} est en ligne.")
            except Exception as e:
                status_code = "N/A"
                status = "DOWN"
                error = str(e)
                print(f"[HORS LIGNE] {site['Name']} : {e}")

            ssl_warning = False
            ssl_expiry_date = ""

            if status == "UP":
                hostname = site['URL'].split("//")[-1].split("/")[0]
                threshold_days = int(site.get('SSL_Expiry_Threshold', 30))
                ssl_warning, ssl_expiry_date = check_ssl_expiry(hostname, threshold_days)
                if ssl_warning:
                    status = "WARNING_SSL"
                    print(f"[WARNING_SSL] {site['Name']} : Le certificat SSL expire bient√¥t.")

            writer.writerow([now, site['Name'], site['URL'], status_code, error, status, ssl_expiry_date])
            current_status[site['Name']] = status

            # Notification Discord si changement de statut
            if discord_enabled and 'Webhook' in site and site['Webhook']:
                previous = previous_status.get(site['Name'])
                if previous != status:
                    emoji = "üü¢" if status == "UP" else "üî¥" if status == "DOWN" else "‚ö†Ô∏è"
                    message = f"{emoji} **{site['Name']}** est **{status}** (√©tait {previous})\n{site['URL']}"
                    if status == "WARNING_SSL":
                        message += f"\nLe certificat SSL expire le {ssl_expiry_date}."
                    send_discord_notification(site['Webhook'], message)

    with open(status_file, 'w') as f:
        json.dump(current_status, f, indent=2)

    print(f"\\n‚úÖ Fichier de log g√©n√©r√© : {log_file}")

### üì§ **Export de l‚Äôhistorique**
def export_site_history(site_names):
    log_dir = "log"
    export_dir = "export"
    os.makedirs(export_dir, exist_ok=True)
    timestamp = datetime.now().strftime('%Y%m%d_%H_%M_%S')
    export_file = os.path.join(export_dir, f"export_{timestamp}.csv")

    with open(export_file, 'w', newline='', encoding='utf-8') as export:
        writer = csv.writer(export)
        writer.writerow(["Date/Heure", "Nom", "URL", "Code HTTP", "Erreur", "Statut", "SSL Expiry Date"])

        for log_file in os.listdir(log_dir):
            if log_file.endswith(".csv"):
                with open(os.path.join(log_dir, log_file), 'r', encoding='utf-8') as log:
                    reader = csv.DictReader(log)
                    for row in reader:
                        if row['Nom'] in site_names:
                            writer.writerow([row["Date/Heure"], row["Nom"], row["URL"], row["Code HTTP"], row["Erreur"], row["Statut"], row["SSL Expiry Date"]])
    print(f"\\n‚úÖ Rapport export√© : {export_file}")

### üöÄ **Point d‚Äôentr√©e principal**
def main():
    parser = argparse.ArgumentParser(description="Surveillance de services web")
    parser.add_argument('--add', nargs='+', help="Ajouter un site (optionnel : webhook, SSL expiry threshold)")
    parser.add_argument('--remove', metavar='NOM', help="Supprimer un site")
    parser.add_argument('--list', action='store_true', help="Lister les sites")
    parser.add_argument('--check', action='store_true', help="V√©rifier les sites")
    parser.add_argument('--discord', action='store_true', help="Envoyer les changements d'√©tat sur Discord")
    parser.add_argument('--export', nargs='+', metavar='NOM', help="Exporter l'historique des v√©rifications pour un ou plusieurs sites")
    args = parser.parse_args()

    create_config_file()

    if args.add:
        if len(args.add) < 2:
            print("Erreur : vous devez fournir au moins un nom et une URL.")
        else:
            name = args.add[0]
            url = args.add[1]
            webhook = args.add[2] if len(args.add) > 2 else ""
            ssl_expiry_threshold = int(args.add[3]) if len(args.add) > 3 else 30
            add_site(name, url, webhook, ssl_expiry_threshold)

    elif args.remove:
        remove_site(args.remove)

    elif args.list:
        list_sites()

    elif args.check:
        check_sites(args.discord)

    elif args.export:
        export_site_history(args.export)

if __name__ == "__main__":
    main()
"""

# √âcrire le code comment√© dans un nouveau fichier
with open('main_commente.py', 'w') as file:
    file.write(commented_code)

print("Le fichier 'main_commente.py' a √©t√© g√©n√©r√© avec succ√®s.")

